"Pull image layers using Bazel downloader"

_attrs = {
    "image": attr.string(doc = "The name of the image we are fetching, e.g. gcr.io/distroless/static"),
    "reference": attr.string(doc = "The digest of the manifest"),
    "index": attr.string(doc = "content of the index.json file"),
}

def _download(rctx, tag, output, type = "manifests"):
    if type != "blobs" and type != "manifests":
        fail("type must be blobs or manifests")

    firstslash = rctx.attr.image.find("/")
    registry_url = "https://{host}/v2/{image}/{type}/{tag}".format(
        host = rctx.attr.image[:firstslash],
        image = rctx.attr.image[firstslash + 1:],
        type = type,
        tag = tag,
    )

    sha256 = None
    if tag.startswith("sha256:"):
        sha256 = tag[len("sha256:"):]
    rctx.download(
        url = registry_url,
        sha256 = sha256,
        output = output,
    )
    if type == "manifests":
        return json.decode(rctx.read(output))
    return None

def _download_blobs(rctx, tag, output):
    _download(rctx, tag, output, "blobs")

_build_file_header = """\
# Generated by oci_pull

load("@aspect_bazel_lib//lib:copy_to_directory.bzl", "copy_to_directory")
load("@bazel_skylib//rules:write_file.bzl", "write_file")

package(default_visibility = ["//visibility:public"])
"""

# Mimic the output of crane pull --format=oci
_image_target = """\

write_file(
    name = "write_layout",
    out = "oci-layout",
    content = [json.encode({{
        "imageLayoutVersion": "1.0.0"
    }})],
)

# TODO: should we jq this to include only manifests with matching platform?
# Error: layout contains 5 entries, consider --index
write_file(
    name = "write_index",
    out = "index.json",
    content = [\"\"\"{index_content}\"\"\"],
)

copy_to_directory(
    name = "blobs",
    out = "blobs/sha256",
    include_external_repositories = ["*"],
    srcs = {tars} + [
        ":{manifest_file}",
        #":{config_file}",
    ],
)

copy_to_directory(
    name = "image",
    out = "layout",
    include_external_repositories = ["*"],
    srcs = [
        "blobs",
        "oci-layout",
        "index.json",
    ],
)
"""

_alias_target = """\
alias(
    name = "{name}",
    actual = select({{
        "@platforms//cpu:arm64": "@{name}_linux_arm64//:image",
        "@platforms//cpu:x86_64": "@{name}_linux_amd64//:image",
    }}),
    visibility = ["//visibility:public"],
)
"""

def _pull_impl(rctx):
    build_content = [_build_file_header]

    image_mf_file = rctx.attr.reference.replace("sha256:", "")
    image_mf = _download(rctx, rctx.attr.reference, image_mf_file)

    #image_config_file = image_mf["config"]["digest"].replace("sha256:", "")
    #image_config = _download(rctx, image_mf["config"]["digest"], image_config_file)
    tars = []
    for layer in image_mf["layers"]:
        sha256 = layer["digest"].replace("sha256:", "")
        _download_blobs(rctx, layer["digest"], sha256)
        tars.append(sha256)

    build_content.append(_image_target.format(
        name = rctx.attr.name,
        tars = tars,
        index_content = rctx.attr.index,
        manifest_file = image_mf_file,
        config_file = "",  #image_config_file,
    ))

    build_content.append(_alias_target.format(name = rctx.attr.name))
    rctx.file("BUILD.bazel", content = "\n".join(build_content))

oci_pull_rule = repository_rule(
    implementation = _pull_impl,
    attrs = _attrs,
)

def _alias_impl(rctx):
    rctx.file("BUILD.bazel", content = _alias_target.format(name = rctx.attr.name))

oci_alias_rule = repository_rule(
    implementation = _alias_impl,
    attrs = {},
)

# Create one external repo per platform, to avoid fetching unneeded layers
def oci_pull(name, manifest):
    """Generate an oci_pull rule for each platform.

    Args:
        name: name of resulting repository
        manifest: a dictionary matching the manifest list structure, mirrored from remote, see docs
    """
    if manifest["mediaType"] != "application/vnd.docker.distribution.manifest.list.v2+json":
        fail("""Expected image manifest to be a manifest list type, with
        "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json"
        Check how you fetched this manifest.""")
    if not manifest["image"]:
        fail("The name of the image must be repeated in the manifest")
    for mf in manifest["manifests"]:
        oci_pull_rule(
            name = "_".join([name, mf["platform"]["os"], mf["platform"]["architecture"]]),
            reference = mf["digest"],
            image = manifest["image"],
            index = json.encode(manifest),
        )
    oci_alias_rule(
        name = name,
    )
