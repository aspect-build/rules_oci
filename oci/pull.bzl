"""A repository rule (used in WORKSPACE) to pull image layers using Bazel's downloader"""

def _download(rctx, identifier, output, resource = "blobs"):
    "Use the Bazel Downloader to fetch from the remote registry"

    if resource != "blobs" and resource != "manifests":
        fail("resource must be blobs or manifests")

    # Construct the URL to fetch from remote, see
    # https://github.com/google/go-containerregistry/blob/62f183e54939eabb8e80ad3dbc787d7e68e68a43/pkg/v1/remote/descriptor.go#L234
    firstslash = rctx.attr.image.find("/")
    registry_url = "https://{registry}/v2/{repository}/{resource}/{identifier}".format(
        registry = rctx.attr.image[:firstslash],
        repository = rctx.attr.image[firstslash + 1:],
        resource = resource,
        identifier = identifier,
    )

    sha256 = None
    if identifier.startswith("sha256:"):
        sha256 = identifier[len("sha256:"):]
    else:
        # buildifier: disable=print
        print("WARNING: fetching from {} without a digest, check your oci_pull configuration")
    rctx.download(
        output = output,
        sha256 = sha256,
        url = registry_url,
    )
    if resource == "manifests":
        return json.decode(rctx.read(output))
    return None

_build_file = """\
"Generated by oci_pull"

load("@aspect_bazel_lib//lib:copy_to_directory.bzl", "copy_to_directory")
load("@bazel_skylib//rules:write_file.bzl", "write_file")

package(default_visibility = ["//visibility:public"])

# Mimic the output of crane pull [image] layout --format=oci
write_file(
    name = "write_layout",
    out = "oci-layout",
    content = [json.encode({{
        "imageLayoutVersion": "1.0.0"
    }})],
)

# TODO: should we transform this to include only manifests with matching platform?
# We copy the entire index with all platforms, while crane writes this file with only the one platform.
write_file(
    name = "write_index",
    out = "index.json",
    content = [\"\"\"{index_content}\"\"\"],
)

copy_to_directory(
    name = "blobs",
    out = "blobs/sha256",
    include_external_repositories = ["*"],
    srcs = {tars} + [
        ":{manifest_file}",
        ":{config_file}",
    ],
)

copy_to_directory(
    name = "image",
    out = "layout",
    include_external_repositories = ["*"],
    srcs = [
        "blobs",
        "oci-layout",
        "index.json",
    ],
)
"""

_alias_target = """\
alias(
    name = "{name}",
    actual = select({{
        "@platforms//cpu:arm64": "@{name}_linux_arm64//:image",
        "@platforms//cpu:x86_64": "@{name}_linux_amd64//:image",
    }}),
    visibility = ["//visibility:public"],
)
"""

def _pull_impl(rctx):
    image_mf_file = rctx.attr.reference.replace("sha256:", "")
    image_mf = _download(rctx, rctx.attr.reference, image_mf_file, resource = "manifests")

    image_config_file = image_mf["config"]["digest"].replace("sha256:", "")
    image_config = _download(rctx, image_mf["config"]["digest"], image_config_file)
    tars = []
    for layer in image_mf["layers"]:
        sha256 = layer["digest"].replace("sha256:", "")
        _download(rctx, layer["digest"], sha256)
        tars.append(sha256)

    rctx.file("BUILD.bazel", content = _build_file.format(
        name = rctx.attr.name,
        tars = tars,
        index_content = rctx.attr.index,
        manifest_file = image_mf_file,
        config_file = image_config_file,
    ))

oci_pull_rule = repository_rule(
    implementation = _pull_impl,
    attrs = {
        "image": attr.string(doc = "The name of the image we are fetching, e.g. gcr.io/distroless/static"),
        "reference": attr.string(doc = "The digest of the manifest"),
        "index": attr.string(doc = "content of the index.json file"),
    },
)

def _alias_impl(rctx):
    rctx.file("BUILD.bazel", content = _alias_target.format(name = rctx.attr.name))

oci_alias_rule = repository_rule(
    implementation = _alias_impl,
    attrs = {},
)

# Create one external repo per platform, to avoid fetching unneeded layers
def oci_pull(name, manifest):
    """Generate an oci_pull rule for each platform.

    Creates repositories like [name]_linux_amd64 containing an :image target.
    Each of these is an OCI layout directory.

    Args:
        name: name of resulting repository with an alias target that selects per-platform.
        manifest: a dictionary matching the manifest list structure, mirrored from remote, see docs.
    """
    if manifest["mediaType"] != "application/vnd.docker.distribution.manifest.list.v2+json":
        fail("""Expected image manifest to be a manifest list type, with
        "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",
        not {}
        Check how you fetched this manifest.""".format(manifest["mediaType"]))
    if not manifest["image"]:
        fail("The name of the image must be repeated in the manifest. See mirror.sh")
    for mf in manifest["manifests"]:
        oci_pull_rule(
            name = "_".join([name, mf["platform"]["os"], mf["platform"]["architecture"]]),
            reference = mf["digest"],
            image = manifest["image"],
            index = json.encode(manifest),
        )
    oci_alias_rule(
        name = name,
    )
