"""A repository rule (used in WORKSPACE) to pull image layers using Bazel's downloader"""

load("@aspect_bazel_lib//lib:paths.bzl", "BASH_RLOCATION_FUNCTION")

def _download(rctx, identifier, output, resource = "blobs"):
    "Use the Bazel Downloader to fetch from the remote registry"

    if resource != "blobs" and resource != "manifests":
        fail("resource must be blobs or manifests")

    # Construct the URL to fetch from remote, see
    # https://github.com/google/go-containerregistry/blob/62f183e54939eabb8e80ad3dbc787d7e68e68a43/pkg/v1/remote/descriptor.go#L234
    firstslash = rctx.attr.image.find("/")
    registry_url = "https://{registry}/v2/{repository}/{resource}/{identifier}".format(
        registry = rctx.attr.image[:firstslash],
        repository = rctx.attr.image[firstslash + 1:],
        resource = resource,
        identifier = identifier,
    )

    if identifier.startswith("sha256:"):
        rctx.download(
            output = output,
            sha256 = identifier[len("sha256:"):],
            url = registry_url,
        )
    else:
        # buildifier: disable=print
        print("WARNING: fetching from {} without a sha256 integrity hash. The result will not be cached".format(registry_url))
        rctx.download(
            output = output,
            url = registry_url,
        )

    if resource == "manifests":
        return json.decode(rctx.read(output))
    return None

_build_file = """\
"Generated by oci_pull"

load("@aspect_bazel_lib//lib:copy_to_directory.bzl", "copy_to_directory")
load("@bazel_skylib//rules:write_file.bzl", "write_file")

package(default_visibility = ["//visibility:public"])

# Mimic the output of crane pull [image] layout --format=oci
write_file(
    name = "write_layout",
    out = "oci-layout",
    content = [json.encode({{
        "imageLayoutVersion": "1.0.0"
    }})],
)

# TODO: should we transform this to include only manifests with matching platform?
# We copy the entire index with all platforms, while crane writes this file with only the one platform.
write_file(
    name = "write_index",
    out = "index.json",
    content = [\"\"\"{index_content}\"\"\"],
)

copy_to_directory(
    name = "blobs",
    out = "blobs/sha256",
    include_external_repositories = ["*"],
    srcs = {tars} + [
        ":{manifest_file}",
        ":{config_file}",
    ],
)

copy_to_directory(
    name = "image",
    out = "layout",
    include_external_repositories = ["*"],
    srcs = [
        "blobs",
        "oci-layout",
        "index.json",
    ],
)
"""

_alias_target = """\
alias(
    name = "{name}",
    actual = select({{
        "@platforms//cpu:arm64": "@{name}_linux_arm64//:image",
        "@platforms//cpu:x86_64": "@{name}_linux_amd64//:image",
    }}),
    visibility = ["//visibility:public"],
)
"""

def _pull_impl(rctx):
    image_mf_file = rctx.attr.reference.replace("sha256:", "")
    image_mf = _download(rctx, rctx.attr.reference, image_mf_file, resource = "manifests")

    image_config_file = image_mf["config"]["digest"].replace("sha256:", "")
    image_config = _download(rctx, image_mf["config"]["digest"], image_config_file)
    tars = []
    for layer in image_mf["layers"]:
        sha256 = layer["digest"].replace("sha256:", "")
        _download(rctx, layer["digest"], sha256)
        tars.append(sha256)

    rctx.file("BUILD.bazel", content = _build_file.format(
        name = rctx.attr.name,
        tars = tars,
        index_content = rctx.attr.index,
        manifest_file = image_mf_file,
        config_file = image_config_file,
    ))

oci_pull_rule = repository_rule(
    implementation = _pull_impl,
    attrs = {
        "image": attr.string(doc = "The name of the image we are fetching, e.g. gcr.io/distroless/static", mandatory = True),
        "reference": attr.string(doc = "The digest of the manifest list", mandatory = True),
        "os": attr.string(doc = "platform os", mandatory = True),
        "architecture": attr.string(doc = "platform architecture", mandatory = True),
    },
)

def _alias_impl(rctx):
    rctx.file("BUILD.bazel", content = _alias_target.format(name = rctx.attr.name))

oci_alias_rule = repository_rule(
    implementation = _alias_impl,
    attrs = {},
)

# Create one external repo per platform, to avoid fetching unneeded layers
def oci_pull2(name, manifest):
    """Generate an oci_pull rule for each platform.

    Creates repositories like [name]_linux_amd64 containing an :image target.
    Each of these is an OCI layout directory.

    Args:
        name: name of resulting repository with an alias target that selects per-platform.
        manifest: a dictionary matching the manifest list structure, mirrored from remote, see docs.
    """
    if manifest["mediaType"] != "application/vnd.docker.distribution.manifest.list.v2+json":
        fail("""Expected image manifest to be a manifest list type, with
        "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",
        not {}
        Check how you fetched this manifest.""".format(manifest["mediaType"]))
    if not manifest["image"]:
        fail("The name of the image must be repeated in the manifest. See mirror.sh")
    for mf in manifest["manifests"]:
        oci_pull_rule(
            name = "_".join([name, mf["platform"]["os"], mf["platform"]["architecture"]]),
            reference = mf["digest"],
            image = manifest["image"],
            index = json.encode(manifest),
        )
    oci_alias_rule(
        name = name,
    )

_latest_build = """\
load("@aspect_bazel_lib//lib:jq.bzl", "jq")
load("@bazel_skylib//rules:write_file.bzl", "write_file")

jq(
    name = "platforms",
    srcs = ["manifest_list.json"],
    filter = ".manifests[] | .platform",
)

# TODO this isn't finished at all
write_file(
    name = "pin_sh",
    out = "pin.sh",
    content = [
        "#!/usr/bin/env bash",
        \"\"\"{rlocation}\"\"\",
        "cat $(rlocation {name}/manifest_list.sha256)",
        "echo oci_pull",
        "echo digest = sha256:,",
        "echo platforms = [",
        "cat $(rlocation {name}/platforms.json)",
        "echo ]",
        
    ],
)

sh_binary(
    name = "pin",
    srcs = ["pin.sh"],
    data = [
        "manifest_list.sha256",
        ":platforms",
        "@bazel_tools//tools/bash/runfiles",
    ],
)
"""

def _pull_latest_impl(rctx):
    _download(rctx, "latest", "manifest_list.json", "manifests")
    result = rctx.execute(["shasum", "-a", "256", "manifest_list.json"])
    if result.return_code:
        msg = "shasum failed: \nSTDOUT:\n%s\nSTDERR:\n%s" % (result.stdout, result.stderr)
        fail(msg)
    rctx.file("manifest_list.sha256", result.stdout)
    rctx.file("BUILD.bazel", _latest_build.format(
        name = rctx.attr.name,
        rlocation = BASH_RLOCATION_FUNCTION,
    ))

    # buildifier: disable=print
    print("""\
    WARNING: for reproducible builds, we recommend pinning as follows:
    bazel run @{}//:pin
    """.format(rctx.attr.name))

pull_latest = repository_rule(_pull_latest_impl, attrs = {"image": attr.string()})

# buildifier: disable=function-docstring
def oci_pull(name, image, platforms = None, digest = None):
    if digest == None:
        pull_latest(name = name, image = image)
        return
    for plat in platforms:
        oci_pull_rule(
            name = "_".join([name, plat["os"], plat["architecture"]]),
            image = image,
            reference = digest,
            os = plat["os"],
            architecture = plat["architecture"],
        )
